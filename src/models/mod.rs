mod params;

pub mod message;
pub mod post;
pub mod user;

use serde::de::DeserializeOwned;
use serde::Serialize;
use surreal_simple_querybuilder::queries::QueryBuilderInjecter;
use surrealdb::opt::PatchOp;
use surrealdb::opt::QueryResult;
use surrealdb::sql::thing;

pub use message::*;
pub use post::*;
pub use user::*;

use crate::client::DB;
use crate::errors::ApiResult;

#[async_trait::async_trait]
pub trait Model
where
  Self: Sized + Serialize + DeserializeOwned + Send + Sync,
{
  fn table() -> &'static str;
  fn id(&self) -> Option<&str>;

  //////////////////////////////////////////////////////////////////////////////

  async fn m_create(self) -> ApiResult<Self> {
    let mut item = DB.create(Self::table()).content(self).await?;

    unwrap_or_api_error(item.pop())
  }

  //////////////////////////////////////////////////////////////////////////////

  async fn m_delete(&self) -> ApiResult<()> {
    if let Some(id) = self.id() {
      Self::m_delete_one(id).await?;
    }

    Ok(())
  }

  /// Delete a node using its ID
  async fn m_delete_one(id: &str) -> ApiResult<Self> {
    let item = DB.delete(thing(id)?).await?;

    unwrap_or_api_error(item)
  }

  //////////////////////////////////////////////////////////////////////////////

  async fn m_update(self) -> ApiResult<Self> {
    if let Some(id) = self.id() {
      let item = DB.update(thing(id)?).content(self).await?;

      unwrap_or_api_error(item)
    } else {
      Ok(self)
    }
  }

  //////////////////////////////////////////////////////////////////////////////

  async fn m_merge_one(id: &str, merge: impl Serialize + Send) -> ApiResult<Self> {
    let item = DB.update(thing(id)?).merge(merge).await?;

    unwrap_or_api_error(item)
  }

  async fn merge(self, merge: impl Serialize + Send) -> ApiResult<Self> {
    match self.id() {
      Some(id) => Self::m_merge_one(id, merge).await,
      None => Ok(self),
    }
  }

  //////////////////////////////////////////////////////////////////////////////

  /// Add a value to a field, it can be an item in an array or a suffix to a string.
  ///
  async fn m_add_one(id: &str, field: &str, value: impl Serialize + Send) -> ApiResult<Self> {
    let item = DB
      .update(thing(id)?)
      .patch(PatchOp::add(field, value))
      .await?;

    unwrap_or_api_error(item)
  }

  async fn m_add(self, field: &str, value: impl Serialize + Send) -> ApiResult<Self> {
    match self.id() {
      Some(id) => Self::m_add_one(id, field, value).await,
      None => Ok(self),
    }
  }

  //////////////////////////////////////////////////////////////////////////////

  /// Remove a value from a field, it can be an item from an array or a suffix
  /// from a string.
  ///
  async fn m_remove_one(id: &str, field: &str, index_or_subfield: &str) -> ApiResult<Self> {
    let item = DB
      .update(thing(id)?)
      .patch(PatchOp::remove(&format!("{field}/{index_or_subfield}")))
      .await?;

    unwrap_or_api_error(item)
  }

  //////////////////////////////////////////////////////////////////////////////

  async fn m_find<'a, R>(params: impl QueryBuilderInjecter<'a> + Send + 'a) -> ApiResult<R>
  where
    R: DeserializeOwned,
    usize: QueryResult<R>,
  {
    let (query, params) = surreal_simple_querybuilder::queries::select("*", Self::table(), params)?;

    #[cfg(debug_assertions)]
    println!("");
    #[cfg(debug_assertions)]
    println!("ðŸ”® query  = {query}");
    #[cfg(debug_assertions)]
    println!("ðŸ”® params = {params:#?}");

    let items = DB.query(query).bind(params).await?.take(0)?;

    Ok(items)
  }
}

fn unwrap_or_api_error<Opt>(some: Option<Opt>) -> ApiResult<Opt> {
  match some {
    Some(v) => Ok(v),
    None => Err("unwrap-on-none".into()),
  }
}

/// This could be a Derive macro but i'm too lazy to do it.
///
/// # Usage
/// Quickly implement the `Model` trait on any struct that has a `id` field
/// and that lives alongside a `schema` generated by the `model` macro:
///
/// ```
/// pub struct INode {
///   #[serde(skip_serializing_if = "Option::is_none")]
///   pub id: Option<String>,
/// }
/// model!(Node {});
/// with_model!(INode);
/// ```
#[macro_export]
macro_rules! with_model {
    ($($struct:tt)+) => {
      impl crate::Model for $($struct)+ {
        fn table() -> &'static str {
          &*schema::model
        }

        fn id(&self) -> Option<&str> {
          self.id.as_deref()
        }
      }
    };
}
